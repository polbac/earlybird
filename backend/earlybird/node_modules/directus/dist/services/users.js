"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersService = void 0;
const argon2_1 = __importDefault(require("argon2"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const lodash_1 = require("lodash");
const database_1 = __importDefault(require("../database"));
const env_1 = __importDefault(require("../env"));
const exceptions_1 = require("@directus/shared/exceptions");
const exceptions_2 = require("../exceptions");
const record_not_unique_1 = require("../exceptions/database/record-not-unique");
const logger_1 = __importDefault(require("../logger"));
const is_url_allowed_1 = __importDefault(require("../utils/is-url-allowed"));
const utils_1 = require("@directus/shared/utils");
const authentication_1 = require("./authentication");
const items_1 = require("./items");
const mail_1 = require("./mail");
const settings_1 = require("./settings");
const stall_1 = require("../utils/stall");
const perf_hooks_1 = require("perf_hooks");
class UsersService extends items_1.ItemsService {
    constructor(options) {
        super('directus_users', options);
        this.knex = options.knex || database_1.default();
        this.accountability = options.accountability || null;
        this.service = new items_1.ItemsService('directus_users', options);
        this.schema = options.schema;
    }
    /**
     * User email has to be unique case-insensitive. This is an additional check to make sure that
     * the email is unique regardless of casing
     */
    async checkUniqueEmails(emails, excludeKey) {
        if (emails.length > 0) {
            const query = this.knex
                .select('email')
                .from('directus_users')
                .whereRaw(`LOWER(??) IN (${emails.map(() => '?')})`, ['email', ...emails]);
            if (excludeKey) {
                query.whereNot('id', excludeKey);
            }
            const results = await query;
            if (results.length > 0) {
                throw new record_not_unique_1.RecordNotUniqueException('email', {
                    collection: 'directus_users',
                    field: 'email',
                    invalid: results[0].email,
                });
            }
        }
    }
    /**
     * Check if the provided password matches the strictness as configured in
     * directus_settings.auth_password_policy
     */
    async checkPasswordPolicy(passwords) {
        const settingsService = new settings_1.SettingsService({
            schema: this.schema,
            knex: this.knex,
        });
        const { auth_password_policy: policyRegExString } = await settingsService.readSingleton({
            fields: ['auth_password_policy'],
        });
        if (policyRegExString) {
            const wrapped = policyRegExString.startsWith('/') && policyRegExString.endsWith('/');
            const regex = new RegExp(wrapped ? policyRegExString.slice(1, -1) : policyRegExString);
            for (const password of passwords) {
                if (regex.test(password) === false) {
                    throw new exceptions_1.FailedValidationException({
                        message: `Provided password doesn't match password policy`,
                        path: ['password'],
                        type: 'custom.pattern.base',
                        context: {
                            value: password,
                        },
                    });
                }
            }
        }
        return true;
    }
    async checkRemainingAdminExistence(excludeKeys) {
        // Make sure there's at least one admin user left after this deletion is done
        const otherAdminUsers = await this.knex
            .count('*', { as: 'count' })
            .from('directus_users')
            .whereNotIn('directus_users.id', excludeKeys)
            .andWhere({ 'directus_roles.admin_access': true })
            .leftJoin('directus_roles', 'directus_users.role', 'directus_roles.id')
            .first();
        const otherAdminUsersCount = +((otherAdminUsers === null || otherAdminUsers === void 0 ? void 0 : otherAdminUsers.count) || 0);
        if (otherAdminUsersCount === 0) {
            throw new exceptions_2.UnprocessableEntityException(`You can't remove the last admin user from the role.`);
        }
    }
    /**
     * Create a new user
     */
    async createOne(data, opts) {
        var _a;
        const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (email) {
            await this.checkUniqueEmails([email]);
        }
        return await this.service.createOne(data, opts);
    }
    /**
     * Create multiple new users
     */
    async createMany(data, opts) {
        const emails = data
            .map((payload) => payload.email)
            .filter((e) => e)
            .map((e) => e.toLowerCase());
        await this.checkUniqueEmails(emails);
        const passwords = data.map((payload) => payload.password).filter((pw) => pw);
        if (passwords.length > 0) {
            await this.checkPasswordPolicy(passwords);
        }
        return await this.service.createMany(data, opts);
    }
    async updateOne(key, data, opts) {
        var _a;
        if (data.role) {
            const newRole = await this.knex.select('admin_access').from('directus_roles').where('id', data.role).first();
            if (newRole && !newRole.admin_access) {
                await this.checkRemainingAdminExistence([key]);
            }
        }
        const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (email) {
            await this.checkUniqueEmails([email], key);
        }
        if (data.password) {
            await this.checkPasswordPolicy([data.password]);
        }
        if ('tfa_secret' in data) {
            throw new exceptions_2.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
        }
        return await this.service.updateOne(key, data, opts);
    }
    async updateMany(keys, data, opts) {
        var _a;
        if (data.role) {
            const newRole = await this.knex.select('admin_access').from('directus_roles').where('id', data.role).first();
            if (newRole && !newRole.admin_access) {
                await this.checkRemainingAdminExistence(keys);
            }
        }
        const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (email) {
            await this.checkUniqueEmails([email]);
        }
        if (data.password) {
            await this.checkPasswordPolicy([data.password]);
        }
        if ('tfa_secret' in data) {
            throw new exceptions_2.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
        }
        return await this.service.updateMany(keys, data, opts);
    }
    async updateByQuery(query, data, opts) {
        var _a;
        if (data.role) {
            const newRole = await this.knex.select('admin_access').from('directus_roles').where('id', data.role).first();
            if (newRole && !newRole.admin_access) {
                // This is duplicated a touch, but we need to know the keys first
                // Not authenticated:
                const itemsService = new items_1.ItemsService('directus_users', {
                    knex: this.knex,
                    schema: this.schema,
                });
                const readQuery = lodash_1.cloneDeep(query);
                readQuery.fields = ['id'];
                // We read the IDs of the items based on the query, and then run `updateMany`. `updateMany` does it's own
                // permissions check for the keys, so we don't have to make this an authenticated read
                const itemsToUpdate = await itemsService.readByQuery(readQuery);
                const keys = itemsToUpdate.map((item) => item.id);
                await this.checkRemainingAdminExistence(keys);
            }
        }
        const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (email) {
            await this.checkUniqueEmails([email]);
        }
        if (data.password) {
            await this.checkPasswordPolicy([data.password]);
        }
        if ('tfa_secret' in data) {
            throw new exceptions_2.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
        }
        return await this.service.updateByQuery(query, data, opts);
    }
    async deleteOne(key, opts) {
        await this.checkRemainingAdminExistence([key]);
        await this.service.deleteOne(key, opts);
        return key;
    }
    async deleteMany(keys, opts) {
        await this.checkRemainingAdminExistence(keys);
        await this.service.deleteMany(keys, opts);
        return keys;
    }
    async deleteByQuery(query, opts) {
        const primaryKeyField = this.schema.collections[this.collection].primary;
        const readQuery = lodash_1.cloneDeep(query);
        readQuery.fields = [primaryKeyField];
        // Not authenticated:
        const itemsService = new items_1.ItemsService(this.collection, {
            knex: this.knex,
            schema: this.schema,
        });
        const itemsToDelete = await itemsService.readByQuery(readQuery);
        const keys = itemsToDelete.map((item) => item[primaryKeyField]);
        if (keys.length === 0)
            return [];
        return await this.deleteMany(keys, opts);
    }
    async inviteUser(email, role, url, subject) {
        const emails = utils_1.toArray(email);
        if (url && is_url_allowed_1.default(url, env_1.default.USER_INVITE_URL_ALLOW_LIST) === false) {
            throw new exceptions_2.InvalidPayloadException(`Url "${url}" can't be used to invite users.`);
        }
        await this.knex.transaction(async (trx) => {
            const service = new items_1.ItemsService('directus_users', {
                schema: this.schema,
                accountability: this.accountability,
                knex: trx,
            });
            const mailService = new mail_1.MailService({
                schema: this.schema,
                accountability: this.accountability,
                knex: trx,
            });
            for (const email of emails) {
                await service.createOne({ email, role, status: 'invited' });
                const payload = { email, scope: 'invite' };
                const token = jsonwebtoken_1.default.sign(payload, env_1.default.SECRET, { expiresIn: '7d' });
                const inviteURL = url !== null && url !== void 0 ? url : env_1.default.PUBLIC_URL + '/admin/accept-invite';
                const acceptURL = inviteURL + '?token=' + token;
                const subjectLine = subject ? subject : "You've been invited";
                await mailService.send({
                    to: email,
                    subject: subjectLine,
                    template: {
                        name: 'user-invitation',
                        data: {
                            url: acceptURL,
                            email,
                        },
                    },
                });
            }
        });
    }
    async acceptInvite(token, password) {
        const { email, scope } = jsonwebtoken_1.default.verify(token, env_1.default.SECRET);
        if (scope !== 'invite')
            throw new exceptions_2.ForbiddenException();
        const user = await this.knex.select('id', 'status').from('directus_users').where({ email }).first();
        if (!user || user.status !== 'invited') {
            throw new exceptions_2.InvalidPayloadException(`Email address ${email} hasn't been invited.`);
        }
        const passwordHashed = await argon2_1.default.hash(password);
        await this.knex('directus_users').update({ password: passwordHashed, status: 'active' }).where({ id: user.id });
        if (this.cache && env_1.default.CACHE_AUTO_PURGE) {
            await this.cache.clear();
        }
    }
    async requestPasswordReset(email, url, subject) {
        const STALL_TIME = 500;
        const timeStart = perf_hooks_1.performance.now();
        const user = await this.knex.select('id').from('directus_users').where({ email }).first();
        if (!user) {
            await stall_1.stall(STALL_TIME, timeStart);
            throw new exceptions_2.ForbiddenException();
        }
        const mailService = new mail_1.MailService({
            schema: this.schema,
            knex: this.knex,
            accountability: this.accountability,
        });
        const payload = { email, scope: 'password-reset' };
        const token = jsonwebtoken_1.default.sign(payload, env_1.default.SECRET, { expiresIn: '1d' });
        if (url && is_url_allowed_1.default(url, env_1.default.PASSWORD_RESET_URL_ALLOW_LIST) === false) {
            throw new exceptions_2.InvalidPayloadException(`Url "${url}" can't be used to reset passwords.`);
        }
        const acceptURL = url ? `${url}?token=${token}` : `${env_1.default.PUBLIC_URL}/admin/reset-password?token=${token}`;
        const subjectLine = subject ? subject : 'Password Reset Request';
        await mailService.send({
            to: email,
            subject: subjectLine,
            template: {
                name: 'password-reset',
                data: {
                    url: acceptURL,
                    email,
                },
            },
        });
        await stall_1.stall(STALL_TIME, timeStart);
    }
    async resetPassword(token, password) {
        const { email, scope } = jsonwebtoken_1.default.verify(token, env_1.default.SECRET);
        if (scope !== 'password-reset')
            throw new exceptions_2.ForbiddenException();
        const user = await this.knex.select('id', 'status').from('directus_users').where({ email }).first();
        if (!user || user.status !== 'active') {
            throw new exceptions_2.ForbiddenException();
        }
        const passwordHashed = await argon2_1.default.hash(password);
        await this.knex('directus_users').update({ password: passwordHashed, status: 'active' }).where({ id: user.id });
        if (this.cache && env_1.default.CACHE_AUTO_PURGE) {
            await this.cache.clear();
        }
    }
    async generateTFA(pk) {
        const user = await this.knex.select('tfa_secret').from('directus_users').where({ id: pk }).first();
        if ((user === null || user === void 0 ? void 0 : user.tfa_secret) !== null) {
            throw new exceptions_2.InvalidPayloadException('TFA Secret is already set for this user');
        }
        const authService = new authentication_1.AuthenticationService({
            knex: this.knex,
            schema: this.schema,
            accountability: this.accountability,
        });
        const secret = authService.generateTFASecret();
        return {
            secret,
            url: await authService.generateOTPAuthURL(pk, secret),
        };
    }
    async enableTFA(pk, otp, secret) {
        const authService = new authentication_1.AuthenticationService({
            schema: this.schema,
        });
        if (!pk) {
            throw new exceptions_2.InvalidCredentialsException();
        }
        const otpValid = await authService.verifyOTP(pk, otp, secret);
        if (otpValid === false) {
            throw new exceptions_2.InvalidPayloadException(`"otp" is invalid`);
        }
        const userSecret = await this.knex.select('tfa_secret').from('directus_users').where({ id: pk }).first();
        if ((userSecret === null || userSecret === void 0 ? void 0 : userSecret.tfa_secret) !== null) {
            throw new exceptions_2.InvalidPayloadException('TFA Secret is already set for this user');
        }
        await this.knex('directus_users').update({ tfa_secret: secret }).where({ id: pk });
    }
    async disableTFA(pk) {
        await this.knex('directus_users').update({ tfa_secret: null }).where({ id: pk });
    }
    async create(data) {
        logger_1.default.warn('UsersService.create is deprecated and will be removed before v9.0.0. Use createOne or createMany instead.');
        if (Array.isArray(data))
            return this.createMany(data);
        return this.createOne(data);
    }
    async update(data, key) {
        if (Array.isArray(key))
            return await this.updateMany(key, data);
        else if (key)
            await this.updateOne(key, data);
        const primaryKeyField = this.schema.collections[this.collection].primary;
        const keys = [];
        await this.knex.transaction(async (trx) => {
            const itemsService = new items_1.ItemsService(this.collection, {
                accountability: this.accountability,
                knex: trx,
                schema: this.schema,
            });
            const payloads = utils_1.toArray(data);
            for (const single of payloads) {
                const payload = lodash_1.clone(single);
                const key = payload[primaryKeyField];
                if (!key) {
                    throw new exceptions_2.InvalidPayloadException('Primary key is missing in update payload.');
                }
                keys.push(key);
                await itemsService.updateOne(key, payload);
            }
        });
        return keys;
    }
    async delete(key) {
        if (Array.isArray(key))
            return await this.deleteMany(key);
        return await this.deleteOne(key);
    }
}
exports.UsersService = UsersService;
