"use strict";
/**
 * Generate an AST based on a given collection and query
 */
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const get_relation_type_1 = require("../utils/get-relation-type");
async function getASTFromQuery(collection, query, schema, options) {
    var _a;
    query = lodash_1.cloneDeep(query);
    const accountability = options === null || options === void 0 ? void 0 : options.accountability;
    const action = (options === null || options === void 0 ? void 0 : options.action) || 'read';
    const permissions = accountability && accountability.admin !== true
        ? schema.permissions.filter((permission) => {
            return permission.action === action;
        })
        : null;
    const ast = {
        type: 'root',
        name: collection,
        query: query,
        children: [],
    };
    const fields = query.fields || ['*'];
    const deep = query.deep || {};
    // Prevent fields/deep from showing up in the query object in further use
    delete query.fields;
    delete query.deep;
    if (!query.sort) {
        const sortField = (_a = schema.collections[collection]) === null || _a === void 0 ? void 0 : _a.sortField;
        query.sort = [{ column: sortField || schema.collections[collection].primary, order: 'asc' }];
    }
    ast.children = await parseFields(collection, fields, deep);
    return ast;
    async function parseFields(parentCollection, fields, deep) {
        var _a;
        if (!fields)
            return [];
        fields = await convertWildcards(parentCollection, fields);
        if (!fields)
            return [];
        const children = [];
        const relationalStructure = {};
        for (const field of fields) {
            const isRelational = field.includes('.') ||
                // We'll always treat top level o2m fields as a related item. This is an alias field, otherwise it won't return
                // anything
                !!schema.relations.find((relation) => { var _a; return relation.related_collection === parentCollection && ((_a = relation.meta) === null || _a === void 0 ? void 0 : _a.one_field) === field; });
            if (isRelational) {
                // field is relational
                const parts = field.split('.');
                let fieldKey = parts[0];
                let collectionScope = null;
                // m2a related collection scoped field selector `fields=sections.section_id:headings.title`
                if (fieldKey.includes(':')) {
                    const [key, scope] = fieldKey.split(':');
                    fieldKey = key;
                    collectionScope = scope;
                }
                if (fieldKey in relationalStructure === false) {
                    if (collectionScope) {
                        relationalStructure[fieldKey] = { [collectionScope]: [] };
                    }
                    else {
                        relationalStructure[fieldKey] = [];
                    }
                }
                if (parts.length > 1) {
                    const childKey = parts.slice(1).join('.');
                    if (collectionScope) {
                        if (collectionScope in relationalStructure[fieldKey] === false) {
                            relationalStructure[fieldKey][collectionScope] = [];
                        }
                        relationalStructure[fieldKey][collectionScope].push(childKey);
                    }
                    else {
                        relationalStructure[fieldKey].push(childKey);
                    }
                }
            }
            else {
                children.push({ type: 'field', name: field });
            }
        }
        for (const [relationalField, nestedFields] of Object.entries(relationalStructure)) {
            const relatedCollection = getRelatedCollection(parentCollection, relationalField);
            const relation = getRelation(parentCollection, relationalField);
            if (!relation)
                continue;
            const relationType = get_relation_type_1.getRelationType({
                relation,
                collection: parentCollection,
                field: relationalField,
            });
            if (!relationType)
                continue;
            let child = null;
            if (relationType === 'm2a') {
                const allowedCollections = relation.meta.one_allowed_collections.filter((collection) => {
                    if (!permissions)
                        return true;
                    return permissions.some((permission) => permission.collection === collection);
                });
                child = {
                    type: 'm2a',
                    names: allowedCollections,
                    children: {},
                    query: {},
                    relatedKey: {},
                    parentKey: schema.collections[parentCollection].primary,
                    fieldKey: relationalField,
                    relation: relation,
                };
                for (const relatedCollection of allowedCollections) {
                    child.children[relatedCollection] = await parseFields(relatedCollection, Array.isArray(nestedFields) ? nestedFields : nestedFields[relatedCollection] || ['*'], deep === null || deep === void 0 ? void 0 : deep[`${relationalField}:${relatedCollection}`]);
                    child.query[relatedCollection] = getDeepQuery((deep === null || deep === void 0 ? void 0 : deep[`${relationalField}:${relatedCollection}`]) || {});
                    child.relatedKey[relatedCollection] = schema.collections[relatedCollection].primary;
                }
            }
            else if (relatedCollection) {
                if (permissions && permissions.some((permission) => permission.collection === relatedCollection) === false) {
                    continue;
                }
                child = {
                    type: relationType,
                    name: relatedCollection,
                    fieldKey: relationalField,
                    parentKey: schema.collections[parentCollection].primary,
                    relatedKey: schema.collections[relatedCollection].primary,
                    relation: relation,
                    query: getDeepQuery((deep === null || deep === void 0 ? void 0 : deep[relationalField]) || {}),
                    children: await parseFields(relatedCollection, nestedFields, (deep === null || deep === void 0 ? void 0 : deep[relationalField]) || {}),
                };
                if (relationType === 'o2m' && !child.query.sort) {
                    child.query.sort = [
                        { column: ((_a = relation.meta) === null || _a === void 0 ? void 0 : _a.sort_field) || schema.collections[relation.collection].primary, order: 'asc' },
                    ];
                }
            }
            if (child) {
                children.push(child);
            }
        }
        return children;
    }
    async function convertWildcards(parentCollection, fields) {
        var _a;
        fields = lodash_1.cloneDeep(fields);
        const fieldsInCollection = Object.entries(schema.collections[parentCollection].fields).map(([name]) => name);
        let allowedFields = fieldsInCollection;
        if (permissions) {
            const permittedFields = (_a = permissions.find((permission) => parentCollection === permission.collection)) === null || _a === void 0 ? void 0 : _a.fields;
            if (permittedFields !== undefined)
                allowedFields = permittedFields;
        }
        if (!allowedFields || allowedFields.length === 0)
            return [];
        // In case of full read permissions
        if (allowedFields[0] === '*')
            allowedFields = fieldsInCollection;
        for (let index = 0; index < fields.length; index++) {
            const fieldKey = fields[index];
            if (fieldKey.includes('*') === false)
                continue;
            if (fieldKey === '*') {
                // Set to all fields in collection
                if (allowedFields.includes('*')) {
                    fields.splice(index, 1, ...fieldsInCollection);
                }
                else {
                    // Set to all allowed fields
                    fields.splice(index, 1, ...allowedFields);
                }
            }
            // Swap *.* case for *,<relational-field>.*,<another-relational>.*
            if (fieldKey.includes('.') && fieldKey.split('.')[0] === '*') {
                const parts = fieldKey.split('.');
                const relationalFields = allowedFields.includes('*')
                    ? schema.relations
                        .filter((relation) => relation.collection === parentCollection || relation.related_collection === parentCollection)
                        .map((relation) => {
                        var _a;
                        const isMany = relation.collection === parentCollection;
                        return isMany ? relation.field : (_a = relation.meta) === null || _a === void 0 ? void 0 : _a.one_field;
                    })
                    : allowedFields.filter((fieldKey) => !!getRelation(parentCollection, fieldKey));
                const nonRelationalFields = allowedFields.filter((fieldKey) => relationalFields.includes(fieldKey) === false);
                fields.splice(index, 1, ...[
                    ...relationalFields.map((relationalField) => {
                        return `${relationalField}.${parts.slice(1).join('.')}`;
                    }),
                    ...nonRelationalFields,
                ]);
            }
        }
        return fields;
    }
    function getRelation(collection, field) {
        const relation = schema.relations.find((relation) => {
            var _a;
            return ((relation.collection === collection && relation.field === field) ||
                (relation.related_collection === collection && ((_a = relation.meta) === null || _a === void 0 ? void 0 : _a.one_field) === field));
        });
        return relation;
    }
    function getRelatedCollection(collection, field) {
        var _a;
        const relation = getRelation(collection, field);
        if (!relation)
            return null;
        if (relation.collection === collection && relation.field === field) {
            return relation.related_collection || null;
        }
        if (relation.related_collection === collection && ((_a = relation.meta) === null || _a === void 0 ? void 0 : _a.one_field) === field) {
            return relation.collection || null;
        }
        return null;
    }
}
exports.default = getASTFromQuery;
function getDeepQuery(query) {
    return lodash_1.mapKeys(lodash_1.omitBy(query, (value, key) => key.startsWith('_') === false), (value, key) => key.substring(1));
}
