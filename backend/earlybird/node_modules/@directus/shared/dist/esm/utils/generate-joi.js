import BaseJoi from 'joi';
import { escapeRegExp, merge } from 'lodash';
const Joi = BaseJoi.extend({
    type: 'string',
    base: BaseJoi.string(),
    messages: {
        'string.contains': '{{#label}} must contain [{{#substring}}]',
        'string.ncontains': "{{#label}} can't contain [{{#substring}}]",
    },
    rules: {
        contains: {
            args: [
                {
                    name: 'substring',
                    ref: true,
                    assert: (val) => typeof val === 'string',
                    message: 'must be a string',
                },
            ],
            method(substring) {
                return this.$_addRule({ name: 'contains', args: { substring } });
            },
            validate(value, helpers, { substring }) {
                if (value.includes(substring) === false) {
                    return helpers.error('string.contains', { substring });
                }
                return value;
            },
        },
        ncontains: {
            args: [
                {
                    name: 'substring',
                    ref: true,
                    assert: (val) => typeof val === 'string',
                    message: 'must be a string',
                },
            ],
            method(substring) {
                return this.$_addRule({ name: 'ncontains', args: { substring } });
            },
            validate(value, helpers, { substring }) {
                if (value.includes(substring) === true) {
                    return helpers.error('string.ncontains', { substring });
                }
                return value;
            },
        },
    },
});
const defaults = {
    requireAll: false,
};
/**
 * Generate a Joi schema from a filter object.
 *
 * @param {FieldFilter} filter - Field filter object. Note: does not support _and/_or filters.
 * @param {JoiOptions} [options] - Options for the schema generation.
 * @returns {AnySchema} Joi schema.
 */
export function generateJoi(filter, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    filter = filter || {};
    options = merge({}, defaults, options);
    const schema = {};
    const key = Object.keys(filter)[0];
    if (!key) {
        throw new Error(`[generateJoi] Filter doesn't contain field key. Passed filter: ${JSON.stringify(filter)}`);
    }
    const value = Object.values(filter)[0];
    if (!value) {
        throw new Error(`[generateJoi] Filter doesn't contain filter rule. Passed filter: ${JSON.stringify(filter)}`);
    }
    if (((_a = Object.keys(value)[0]) === null || _a === void 0 ? void 0 : _a.startsWith('_')) === false) {
        schema[key] = Joi.object({
            [key]: generateJoi(value, options),
        });
    }
    else {
        const operator = Object.keys(value)[0];
        const compareValue = Object.values(value)[0];
        if (operator === '_eq') {
            schema[key] = ((_b = schema[key]) !== null && _b !== void 0 ? _b : Joi.any()).equal(compareValue);
        }
        if (operator === '_neq') {
            schema[key] = ((_c = schema[key]) !== null && _c !== void 0 ? _c : Joi.any()).not(compareValue);
        }
        if (operator === '_contains') {
            schema[key] = ((_d = schema[key]) !== null && _d !== void 0 ? _d : Joi.string()).contains(compareValue);
        }
        if (operator === '_ncontains') {
            schema[key] = ((_e = schema[key]) !== null && _e !== void 0 ? _e : Joi.string()).ncontains(compareValue);
        }
        if (operator === '_starts_with') {
            schema[key] = ((_f = schema[key]) !== null && _f !== void 0 ? _f : Joi.string()).pattern(new RegExp(`^${escapeRegExp(compareValue)}.*`), {
                name: 'starts_with',
            });
        }
        if (operator === '_nstarts_with') {
            schema[key] = ((_g = schema[key]) !== null && _g !== void 0 ? _g : Joi.string()).pattern(new RegExp(`^${escapeRegExp(compareValue)}.*`), {
                name: 'starts_with',
                invert: true,
            });
        }
        if (operator === '_ends_with') {
            schema[key] = ((_h = schema[key]) !== null && _h !== void 0 ? _h : Joi.string()).pattern(new RegExp(`.*${escapeRegExp(compareValue)}$`), {
                name: 'ends_with',
            });
        }
        if (operator === '_nends_with') {
            schema[key] = ((_j = schema[key]) !== null && _j !== void 0 ? _j : Joi.string()).pattern(new RegExp(`.*${escapeRegExp(compareValue)}$`), {
                name: 'ends_with',
                invert: true,
            });
        }
        if (operator === '_in') {
            schema[key] = ((_k = schema[key]) !== null && _k !== void 0 ? _k : Joi.any()).equal(...compareValue);
        }
        if (operator === '_nin') {
            schema[key] = ((_l = schema[key]) !== null && _l !== void 0 ? _l : Joi.any()).not(...compareValue);
        }
        if (operator === '_gt') {
            schema[key] = ((_m = schema[key]) !== null && _m !== void 0 ? _m : Joi.number()).greater(Number(compareValue));
        }
        if (operator === '_gte') {
            schema[key] = ((_o = schema[key]) !== null && _o !== void 0 ? _o : Joi.number()).min(Number(compareValue));
        }
        if (operator === '_lt') {
            schema[key] = ((_p = schema[key]) !== null && _p !== void 0 ? _p : Joi.number()).less(Number(compareValue));
        }
        if (operator === '_lte') {
            schema[key] = ((_q = schema[key]) !== null && _q !== void 0 ? _q : Joi.number()).max(Number(compareValue));
        }
        if (operator === '_null') {
            schema[key] = ((_r = schema[key]) !== null && _r !== void 0 ? _r : Joi.any()).valid(null);
        }
        if (operator === '_nnull') {
            schema[key] = ((_s = schema[key]) !== null && _s !== void 0 ? _s : Joi.any()).invalid(null);
        }
        if (operator === '_empty') {
            schema[key] = ((_t = schema[key]) !== null && _t !== void 0 ? _t : Joi.any()).valid('');
        }
        if (operator === '_nempty') {
            schema[key] = ((_u = schema[key]) !== null && _u !== void 0 ? _u : Joi.any()).invalid('');
        }
        if (operator === '_between') {
            const values = compareValue;
            schema[key] = ((_v = schema[key]) !== null && _v !== void 0 ? _v : Joi.number()).greater(values[0]).less(values[1]);
        }
        if (operator === '_nbetween') {
            const values = compareValue;
            schema[key] = ((_w = schema[key]) !== null && _w !== void 0 ? _w : Joi.number()).less(values[0]).greater(values[1]);
        }
        if (operator === '_submitted') {
            schema[key] = ((_x = schema[key]) !== null && _x !== void 0 ? _x : Joi.any()).required();
        }
        if (operator === '_regex') {
            const wrapped = compareValue.startsWith('/') && compareValue.endsWith('/');
            schema[key] = ((_y = schema[key]) !== null && _y !== void 0 ? _y : Joi.string()).regex(new RegExp(wrapped ? compareValue.slice(1, -1) : compareValue));
        }
    }
    schema[key] = (_z = schema[key]) !== null && _z !== void 0 ? _z : Joi.any();
    if (options.requireAll) {
        schema[key] = schema[key].required();
    }
    return Joi.object(schema).unknown();
}
