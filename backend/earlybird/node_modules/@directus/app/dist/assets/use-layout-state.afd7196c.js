import{aj as n,l as e,a0 as t}from"./vendor.cc2194d4.js";function s(n){return n}function i(n){return n}function r(n){return n}function a(n){return n}function l(n){return n}function o(n){return n}const u=n.extend({type:"string",base:n.string(),messages:{"string.contains":"{{#label}} must contain [{{#substring}}]","string.ncontains":"{{#label}} can't contain [{{#substring}}]"},rules:{contains:{args:[{name:"substring",ref:!0,assert:n=>"string"==typeof n,message:"must be a string"}],method(n){return this.$_addRule({name:"contains",args:{substring:n}})},validate:(n,e,{substring:t})=>!1===n.includes(t)?e.error("string.contains",{substring:t}):n},ncontains:{args:[{name:"substring",ref:!0,assert:n=>"string"==typeof n,message:"must be a string"}],method(n){return this.$_addRule({name:"ncontains",args:{substring:n}})},validate:(n,e,{substring:t})=>!0===n.includes(t)?e.error("string.ncontains",{substring:t}):n}}}),d={requireAll:!1};function g(n,t){var s,i,r,a,l,o,c,b,v,m,_,p,f,y,w,h,x,E,R,$,j,q,O,N;n=n||{},t=e.exports.merge({},d,t);const k={},J=Object.keys(n)[0];if(!J)throw new Error(`[generateJoi] Filter doesn't contain field key. Passed filter: ${JSON.stringify(n)}`);const S=Object.values(n)[0];if(!S)throw new Error(`[generateJoi] Filter doesn't contain filter rule. Passed filter: ${JSON.stringify(n)}`);if(!1===(null===(s=Object.keys(S)[0])||void 0===s?void 0:s.startsWith("_")))k[J]=u.object({[J]:g(S,t)});else{const n=Object.keys(S)[0],t=Object.values(S)[0];if("_eq"===n&&(k[J]=(null!==(i=k[J])&&void 0!==i?i:u.any()).equal(t)),"_neq"===n&&(k[J]=(null!==(r=k[J])&&void 0!==r?r:u.any()).not(t)),"_contains"===n&&(k[J]=(null!==(a=k[J])&&void 0!==a?a:u.string()).contains(t)),"_ncontains"===n&&(k[J]=(null!==(l=k[J])&&void 0!==l?l:u.string()).ncontains(t)),"_starts_with"===n&&(k[J]=(null!==(o=k[J])&&void 0!==o?o:u.string()).pattern(new RegExp(`^${e.exports.escapeRegExp(t)}.*`),{name:"starts_with"})),"_nstarts_with"===n&&(k[J]=(null!==(c=k[J])&&void 0!==c?c:u.string()).pattern(new RegExp(`^${e.exports.escapeRegExp(t)}.*`),{name:"starts_with",invert:!0})),"_ends_with"===n&&(k[J]=(null!==(b=k[J])&&void 0!==b?b:u.string()).pattern(new RegExp(`.*${e.exports.escapeRegExp(t)}$`),{name:"ends_with"})),"_nends_with"===n&&(k[J]=(null!==(v=k[J])&&void 0!==v?v:u.string()).pattern(new RegExp(`.*${e.exports.escapeRegExp(t)}$`),{name:"ends_with",invert:!0})),"_in"===n&&(k[J]=(null!==(m=k[J])&&void 0!==m?m:u.any()).equal(...t)),"_nin"===n&&(k[J]=(null!==(_=k[J])&&void 0!==_?_:u.any()).not(...t)),"_gt"===n&&(k[J]=(null!==(p=k[J])&&void 0!==p?p:u.number()).greater(Number(t))),"_gte"===n&&(k[J]=(null!==(f=k[J])&&void 0!==f?f:u.number()).min(Number(t))),"_lt"===n&&(k[J]=(null!==(y=k[J])&&void 0!==y?y:u.number()).less(Number(t))),"_lte"===n&&(k[J]=(null!==(w=k[J])&&void 0!==w?w:u.number()).max(Number(t))),"_null"===n&&(k[J]=(null!==(h=k[J])&&void 0!==h?h:u.any()).valid(null)),"_nnull"===n&&(k[J]=(null!==(x=k[J])&&void 0!==x?x:u.any()).invalid(null)),"_empty"===n&&(k[J]=(null!==(E=k[J])&&void 0!==E?E:u.any()).valid("")),"_nempty"===n&&(k[J]=(null!==(R=k[J])&&void 0!==R?R:u.any()).invalid("")),"_between"===n){const n=t;k[J]=(null!==($=k[J])&&void 0!==$?$:u.number()).greater(n[0]).less(n[1])}if("_nbetween"===n){const n=t;k[J]=(null!==(j=k[J])&&void 0!==j?j:u.number()).less(n[0]).greater(n[1])}if("_submitted"===n&&(k[J]=(null!==(q=k[J])&&void 0!==q?q:u.any()).required()),"_regex"===n){const n=t.startsWith("/")&&t.endsWith("/");k[J]=(null!==(O=k[J])&&void 0!==O?O:u.string()).regex(new RegExp(n?t.slice(1,-1):t))}}return k[J]=null!==(N=k[J])&&void 0!==N?N:u.any(),t.requireAll&&(k[J]=k[J].required()),u.object(k).unknown()}const c=Symbol();function b(){const n=t(c);if(!n)throw new Error("[useLayoutState]: This function has to be used inside a layout component.");return n}export{c as L,i as a,s as b,r as c,a as d,l as e,o as f,g,b as u};
